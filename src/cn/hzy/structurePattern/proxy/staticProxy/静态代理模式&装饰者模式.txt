静态代理模式和装饰者模式

相同点：
	对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。
	对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。
	
	不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。
	
不同点：
	装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。
	用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。
	当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。
	由代理模式代码可知，客户端不关心代理类了哪个类。但代码控制了客户端对委托类的访问。
	当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。
	
	使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。
	
	因为装饰者模式是将装饰对象作为一个参数传递进来，一个装饰器可以装饰实现同一个接口的所有类，
	而静态代理模式是在编码的时候就确定了要代理哪个类，直接在代理对象将被代理对象new出来的，也就是说
	一个代理对象只能代理一个具体的对象。装饰模式主要是强调对类中代码的拓展，而代理模式则偏向于委托类的访问限制。
	
	
如何将装饰器模式转换为静态代理模式？
	将装饰器模式与工厂模式结合
	也就是在装饰器模式的基础上增加一个工厂类，
	在该工厂中将我们要装饰的对象new出来并作为参数传递给装饰者对象的构造函数，（此时也可以称之为代理对象了）
	然后客户端就直接通过工厂得到代理对象

		
	
静态代理模式：  所谓静态代理就是自己要为要代理的类写一个代理类，或者用工具为其生成的代理类，
			总之，就是程序运行前就已经存在的编译好的代理类，这样有时候会觉得非常麻烦，
			也导致非常的不灵活，相比静态代理，动态代理具有更强的灵活性，
			因为它不用在我们设计实现的时候就指定某一个代理类来代理哪一个被代理对象，
			我们可以把这种指定延迟到程序运行时由JVM来实现。
			
			
装饰者模式中，装饰类和被装饰类是聚合关系，一方不存在了，另一方还可以存在
静态代理模式中，代理对象和委托对象为组合关系，代理对象不存在了，委托对象就不存在了





