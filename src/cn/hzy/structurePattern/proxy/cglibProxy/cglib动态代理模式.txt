cglib动态代理模式可以解决动态代理模式不能代理class的问题
（动态代理只能代理接口，因为接口可以多实现，而类只能单继承，动态代理中，代理类已经继承了Proxy）

Spring中就含有cglib动态代理，所以我们此例中引入了spring-core包

从测试类可以看出  代理类  instanceof  委托类 输出为true。
也就是生成的代理类是委托类，当委托类是具体类没有实现什么接口时，就可以采用cglib动态代理模式

注意点：委托类不能有final修饰，因为生成的代理类会继承委托类，加了final就不能继承，就会报错

Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.
    JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
    Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)
    Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.


在Spring的AOP编程中:
如果加入容器的目标对象有实现接口,用JDK代理
如果目标对象没有实现接口,用Cglib代理