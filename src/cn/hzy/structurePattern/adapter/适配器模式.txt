适配器模式分三种：

	类的适配器模式：
		当一个类（Source）并没有实现某一个接口（Targetable）时，而我们需要这一个类中的一些功能（方法）成为那个接口的扩展（实现）时；
		就可以采用类的适配器模式，具体步骤为：
		新建一个适配器类（Adapter）去继承Source并且实现Targetable
		要求：Source类里面需要被拿去扩展的功能（方法）与Targetable需要被扩展的功能（方法）名字要一致
		
	对象的适配器模式：
		实现目的与类的适配器模式一样，只不过更兼容，也就是就算不满足类的适配器模式里面的要求时，对象的适配器模式也能实现目的。
		具体步骤为：
		新建一个适配器类（Adapter）去实现某一个接口（Targetable），不用再去继承Source类了，
		但是这个适配器类需要持有Source类的实例（不管是外部注入还是自己创建的）。
		当适配器类实现这个接口的方法时，就可以直接调用Source里面的方法，达到目的。
		特点：更加兼容，不用要求两个方法名字一样，需要适配器类持有Source类的实例。
		
	接口的适配器模式：
		当一个接口中定义了很多方法，而我们在实际开发中可能只需要用到里面的某一个或者某几个方法，
		采用传统实现模式就必须要实现接口里面的所有方法，哪怕是空实现都还是要实现。
		这个时候就可以采用对象的适配器模式，写一个抽象类去实现这个接口，在这个抽象类里面提供这个接口里面的所有方法的空实现，
		然后我们只需要继承这个抽象类就可以了，需要具体实现什么方法就实现什么方法，随心所欲，为所欲为
		
		ps：个人见解：需要大量用到接口的适配器模式的接口基本上就是当时设计接口时的不严谨，没有遵循设计模式六大原则之接口隔离原则，
					控制接口的大小，不要太大，太大就会出现这种情况，灵活性较差，使用起来很不方便，需要用到接口的适配器模式，
					也不要太小，如果太小会导致系统中接口泛滥，不利于维护，这个需要设计人员综合考虑，————定制服务（定制接口）
					一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。
					
					
					
					
		类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类Adapter，继承原有的类，实现新的接口即可。

		对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Adapter类，持有原类的一个实例，在Adapter类的方法中，调用实例的方法就行。

		接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，实现所有方法，我们写别的类的时候，继承抽象类即可。
					
					
					
					
					